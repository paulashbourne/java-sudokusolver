/*
 * Project Name: Sudoku Solver
 * Author: Paul Ashbourne
 * Function: Solves valid Sudoku puzzles
 * Date of Completion: October 21st 2012
 */
package sudokusolver;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.swing.JTextField;

/**
 *
 * @author Paul
 */
public class SudokuSolver extends javax.swing.JFrame {

    static JTextField[][] tf = new JTextField[9][9]; //declare 2-dimensional JTextField array to represent cell grid

    /**
     * Creates new form SudokuSolver
     */
    public SudokuSolver() {
        initComponents();
        //loop through all JTextFields
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                tf[x][y] = new JTextField(); //create instance JTextField to represent cell
                this.add(tf[x][y]); //add to form
                //set size and location properties
                tf[x][y].setSize(25, 25);
                tf[x][y].setAlignmentX(CENTER_ALIGNMENT);
                tf[x][y].setLocation(30 + (x * (25 + 5) + ((x / 3) * 10)), 30 + (y * (25 + 5) + ((y / 3) * 10)));
                tf[x][y].setVisible(true);
            }
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        cmdClear = new javax.swing.JButton();
        cmdSolve = new javax.swing.JButton();
        lblStatus = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Sudoku Solver by Paul Ashbourne");
        setMaximumSize(new java.awt.Dimension(355, 365));
        setMinimumSize(new java.awt.Dimension(355, 365));
        setResizable(false);

        cmdClear.setText("Clear");
        cmdClear.setMaximumSize(new java.awt.Dimension(65, 25));
        cmdClear.setMinimumSize(new java.awt.Dimension(65, 25));
        cmdClear.setPreferredSize(new java.awt.Dimension(65, 25));
        cmdClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdClearActionPerformed(evt);
            }
        });

        cmdSolve.setText("Solve!");
        cmdSolve.setMaximumSize(new java.awt.Dimension(65, 25));
        cmdSolve.setMinimumSize(new java.awt.Dimension(65, 25));
        cmdSolve.setPreferredSize(new java.awt.Dimension(65, 25));
        cmdSolve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdSolveActionPerformed(evt);
            }
        });

        lblStatus.setText(" ");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblStatus)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(89, 89, 89)
                        .addComponent(cmdSolve, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(34, 34, 34)
                        .addComponent(cmdClear, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(52, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 327, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(cmdClear, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cmdSolve, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(lblStatus))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void cmdClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdClearActionPerformed
        //loop through all text fields
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                tf[x][y].setText(""); //clear text
            }
        }
        setStatus(" "); //clear status
    }//GEN-LAST:event_cmdClearActionPerformed

    private void setStatus(String text) {
        lblStatus.setText(text); //update status label
    }

    private void cmdSolveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdSolveActionPerformed
        //begin solving code
        Cell[][] cell = new Cell[9][9]; //declare cells

        //loop through all JTextField objects
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                if (tf[x][y].getText().equals("")) { //check if value is null
                    cell[x][y] = new Cell(null); //store null value
                } else {
                    cell[x][y] = new Cell((int) tf[x][y].getText().charAt(0) - 49); //calculate integer value from character
                    if (cell[x][y].value < 0 || cell[x][y].value > 8) { //check if character is invalid
                        //update status
                        System.out.println("Invalid character at (" + (x + 1) + "," + (y + 1) + ")");
                        setStatus("Invalid character at (" + (x + 1) + "," + (y + 1) + ")");
                        return; //abort solve
                    }
                }
            }
        }
        Puzzle puzzle = new Puzzle(cell); //create new puzzle
        int[][] solution; //int variable to store solution to puzzle
        if (!puzzle.valid()) { //check if puzzle is valid
            solution = null; //store null solution
        } else {
            solution = puzzle.solve(); //get solution to puzzle
        }
        if (solution == null) { //check if solution is null
            System.out.println("The puzzle has no solution!");
            setStatus("The puzzle has no solution!");
        } else {
            //output solution to screen
            for (int x = 0; x < 9; x++) {
                for (int y = 0; y < 9; y++) {
                    tf[x][y].setText("" + (solution[x][y] + 1));
                }
            }
            System.out.println("Solved!");
            setStatus("Solved!");
        }
    }//GEN-LAST:event_cmdSolveActionPerformed

    public static void main(String args[]) {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;


                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SudokuSolver.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>



        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new SudokuSolver().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cmdClear;
    private javax.swing.JButton cmdSolve;
    private javax.swing.JLabel lblStatus;
    // End of variables declaration//GEN-END:variables
}

class Puzzle {

    Cell[][] cell = new Cell[9][9]; //declare Cell array to store cells in puzzle

    Puzzle(Cell[][] cell) {
        //loop through all cells
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                this.cell[x][y] = new Cell(cell[x][y].value); //store cell values
                if (this.cell[x][y].value == null) { //chek if value is null
                    this.cell[x][y].pv = cell[x][y].pv;
                }
            }
        }
    }

    public int[][] solve() {
        int result; //int variable to store number of values found in current pass
        do {
            checkPossibleValues(); //update possible values for each cell
            result = findValues(); //find values for cells, store number of values found in memory
            if (result == -1) { //check for unsolvable cell
                return null; //return null solution
            }
        } while (result > 0); //loop while at least one value is found

        if (puzzleSolved() == true) { //check if puzzle is solved
            return solution(); //return solution to puzzle
        } else {
            //recursive call
            int[] ec = emptyCell(); //find empty cell, determine a value to try and store in memory
            do {
                Puzzle nPuzzle = new Puzzle(ncell(ec[0], ec[1])); //create new puzzle with guess value
                int[][] nSolution = nPuzzle.solve(); //resursive call, get solution of puzzle
                if (nSolution == null) { //check if null solution
                    cell[ec[0]][ec[1]].eliminateValue(cell[ec[0]][ec[1]].pv.get(0)); //eliminate guessed value from possibilities
                    if (cell[ec[0]][ec[1]].pv.size() == 1) { //check if only one value possible for cell
                        return this.solve(); //try to solve again                   
                    }
                } else {
                    return nSolution; //guess value yielded a solution, return solved puzzle
                }
            } while(true); //loop infinitely (will eventually exit function through return condition)
        }
    }

    //create new cell array based on current with a value inserted into a specified cell
    private Cell[][] ncell(int x, int y) {
        Cell[][] ret = new Cell[9][9]; //declare new cell array
        //loop through all cells
        for (int x1 = 0; x1 < 9; x1++) {
            for (int y1 = 0; y1 < 9; y1++) {
                ret[x1][y1] = new Cell(cell[x1][y1].value); //get value of cell
                if (ret[x1][y1].value == null) { //check if cell value is null
                    ret[x1][y1].pv = new ArrayList<>(cell[x1][y1].pv);
                }
            }
        }
        ret[x][y].value = cell[x][y].pv.get(0); //insert value to specified cell
        return ret; //return new cell array
    }

    private int[] emptyCell() {
        //returns the x and y indices of the first empty cell in an array
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                if (cell[x][y].value == null) { //check if cell is value
                    int[] guessValue = {x, y}; //create array containing x and y indices
                    return guessValue; //return array
                }
            }
        }
        return null; //no empty cells, return null
    }

    private int[][] solution() {
        //reads solved puzzle, stores each value in a 2-dimensional int array
        int[][] solution = new int[9][9]; //declare 2 2-dimensional int array
        //loop through all cells
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                solution[x][y] = cell[x][y].value; //store value in array
            }
        }
        return solution; //return int array
    }

    private boolean puzzleSolved() {
        //checks if the puzzle is solved and returns a boolean value
        //loop through all cells
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                if (cell[x][y].value == null) { //check if cell is empty
                    return false; //return false
                }
            }
        }
        return true; //return true
    }

    private void checkPossibleValues() {
        /* loops through each cell, looks for cells in the same row, columm or box that are solved. Eliminates
         * the values of these solved cells from the cell's list of possible values
         */
        for (int x = 0; x < 9; x++) { //loop through all columns
            for (int y = 0; y < 9; y++) { //loop through all rows
                if (cell[x][y].value == null) { //check if cell is not solved
                    for (int i = 0; i < 9; i++) { //loop through values from 0 to 8

                        //eliminate values in row
                        if (i != x) { //check if index is not equal to x
                            if (cell[i][y].value != null) { //check if cell is solved
                                cell[x][y].eliminateValue(cell[i][y].value); //eliminate possible value
                            }
                        }
                        //eliminate values in column
                        if (i != y) { //check if index is not equal to y
                            if (cell[x][i].value != null) { //check if cell is solved
                                cell[x][y].eliminateValue(cell[x][i].value); //eliminate possible value
                            }
                        }
                    }

                    int[] boxMin = getBoxMin(x, y); //get x and y indices of top-left cell in same box, store in memory

                    //loop through all cells in same box
                    for (int bx = boxMin[0]; bx < boxMin[0] + 3; bx++) {
                        for (int by = boxMin[1]; by < boxMin[1] + 3; by++) {
                            if (bx != x && by != y) { //check if cell is not in same row or column (already checked above)
                                if (cell[bx][by].value != null) { //check if cell is solved
                                    cell[x][y].eliminateValue(cell[bx][by].value); //eliminate possible value
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    public boolean valid() {
        //checks if a given puzzle is valid

        //loop through values from 0 to 8
        for (int i = 0; i < 9; i++) {

            List pv = new ArrayList(); //declare list to store found values
            for (int y = 0; y < 9; y++) { //loop through each row
                if (cell[i][y].value != null) { //check if cell has a value
                    if (pv.contains(cell[i][y].value)) { //check if list already contains this value
                        return false; //duplicate value in row, return false
                    } else {
                        pv.add(cell[i][y].value); //add value to list of found values
                    }
                }
            }

            pv.clear(); //clear list
            for (int x = 0; x < 9; x++) { //loop through each column
                if (cell[x][i].value != null) { //check if cell has a value
                    if (pv.contains(cell[x][i].value)) { //check if list already contains this value
                        return false; //duplicate value in column, return false
                    } else {
                        pv.add(cell[x][i].value); //add value to list of found values
                    }
                }
            }
        }
        //check boxes
        //loop through each box
        for (int xmin = 0; xmin < 7; xmin += 3) {
            for (int ymin = 0; ymin < 7; ymin += 3) {
                List pv = new ArrayList(); //declare new list to store found values in box
                //loop through each cell in box
                for (int x = xmin; x < xmin + 3; x++) {
                    for (int y = ymin; y < ymin + 3; y++) {
                        if (cell[x][y].value != null) { //check if cell has a value
                            if (pv.contains(cell[x][y].value)) { //check if list already contains this value
                                return false; //duplicate value in box, return false
                            } else {
                                pv.add(cell[x][y].value); //add value to list of found values
                            }
                        }
                    }
                }
            }
        }
        return true; //return true
    }

    private int[] getBoxMin(int x, int y) {
        //returns the x and y indices of the top-left cell of the box containing a given cell
        int ret[] = new int[2]; //declare int array to store indices
        if (x < 3) {
            ret[0] = 0;
        } else if (x < 6) {
            ret[0] = 3;
        } else {
            ret[0] = 6;
        }

        if (y < 3) {
            ret[1] = 0;
        } else if (y < 6) {
            ret[1] = 3;
        } else {
            ret[1] = 6;
        }
        return ret;
    }

    private int findValues() {
        /*finds values for cells, returns the number of values found, or -1 if 
         * a cell is found that contains no possible values
         */
        int found = 0; //declare counting variable
        //loop through all cells
        for (int x = 0; x < 9; x++) {
            for (int y = 0; y < 9; y++) {
                if (cell[x][y].value == null) { //check if cell has no value
                    int value = cell[x][y].findValue(); //find value for cell, store in memory
                    if (value == -1) { //check if no possible values
                        return -1; //return -1
                    } else if (value == 1) { //check if a value is found
                        found++; //increment counting variable

                        //eliminate found value from possible values of cells in same row or column
                        for (int z = 0; z < 9; z++) {
                            if (z != x) {
                                cell[z][y].eliminateValue(cell[x][y].value);
                            }
                            if (z != y) {
                                cell[x][z].eliminateValue(cell[x][y].value);
                            }

                            //eliminate found value from possible values of cells in same 3x3 box
                            int[] boxMin = getBoxMin(x, y);
                            for (int bx = boxMin[0]; bx < boxMin[0] + 3; bx++) {
                                for (int by = boxMin[1]; by < boxMin[1] + 3; by++) {
                                    if (bx != x && by != y) {
                                        cell[bx][by].eliminateValue(cell[x][y].value);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return found; //return number of values found
    }
}

class Cell {

    public Integer value; //Integer variable containing the value of the cell. Null if cell has no value
    public List<Integer> pv = new ArrayList<>(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8)); //List containing all possible values for cell

    Cell(Integer value) {
        this.value = value;
    }

    public void eliminateValue(int value) {
        //eliminates a given values from the list of possible values
        int index = pv.indexOf(value); //get index of value
        if (index != -1) { //check if value exists in list
            pv.remove(index); //remove value
        }
    }

    public int findValue() {
        //finds a value for a cell. Returns 1 if value found, 0 if no value found, -1 if cell unsolvable
        if (pv.size() == 1) { //check if list of possible values contains only one element
            value = pv.get(0); //set value to only possible value
            return 1; //return 2 for found value
        } else if (pv.isEmpty()) { //check if no possible values
            return -1; //cell is unsolvable, return -1
        }
        return 0; //no value found, return 0
    }
}